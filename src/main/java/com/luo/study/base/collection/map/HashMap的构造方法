不能空构造方法从头走到结尾，建议既学理论又做实验

HashMap();=HashMap(16, 0.75)
HashMap(int initialCapacity);
//loadFactor负载因子，用来说明什么情况Map会进行扩容，默认的负载因子是0.75（当16个位置的里面的占用率达到75%时，这个时候就需要扩容，
//默认扩容长度是2的倍数，即16*2=32.扩容之后需要重新hash计算元素新的存储位置再进行排列），如果有碰撞，占用也只被统计一次
//扩容和初始化大小都是我们在进行Map优化时必须写的内容
//如果将负载因子写成1，可能因为碰撞的问题，导致这个数组一直没有占满，不扩容，也产生越来越多的碰撞。通常情况下，负载因子0.75我们是不改变的。
//这两个参数的组合是有一定的算法，根据不同的场景计算出来的。不是我们随心所欲写个1写个2之类的，这样做语法不会出错，但是对性能优化没有作用
HashMap(int initialCapacity, float loadFactor);

我们在进行HashMap使用的时候，大家切记不能永远使用空构造方法或者是1个参数构造方法，我们需要根据不同的场景来选择不同的初始化构造方式。
这个也是我们做优化的时候必须了解的一个内容

HashMap的Entry结构

//默认的Map是长度为16的数组，如果两个键值映射恰好对应数组的同一个位置，这时就会用next来描述下一个元素。
//hash用来描述位置
static Class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    final int hash;
}

面试题
1、new HashMap(3)：初始化的长度是3吗？
new HashMap(3)不是创建一个长度为3的HashMap，HashMap的构造方法会将参数3优化转换为大于3的最小的2的n次方，即4。

2、new HashMap(10000, 0.75)要录入的数据有10000条，会产生扩容吗
大于10000的最小的2的n次方=16384*0.75=12288，不会产生扩容

